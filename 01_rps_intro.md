# RPS - въведение

1. [Въведение](01_rps_intro.md)
1. [If/else](02_rps_if_else.md)
1. [Произволен избор и валидация](03_rps_random_choice_and_validation.md)
1. [Съкращаване на кода с хеш таблица](04_rps_hash.md)
1. [Съкращаване на кода с двумерен масив](05_rps_table.md)

Играта, която ще имплементираме, е "Камък-ножица-листо", или "Rock-paper-scissors", или за кратко -- RPS. Искаме програмата да работи горе-долу по следния начин:

    Please enter one of: rock, paper, scissors

След това, играта чака въвеждане на нещо от играча. При въведено "rock" и натискане на `enter`, очакваме резултат, подобен на това:

    You played:      rock
    Computer played: scissors
    You win!

## Общ план

Големите стъпки, през които ще мине кода, изглеждат така:

- Програмата пита потребителя за вход
- Вземаме входа от потребителя
- Компютъра избира произволен ход
- Сравняваме хода на играча и този на компютъра и решаваме кой побеждава
- Извеждаме резултата

Най-трудната част от това е сравнението на хода на играча с този на компютъра. Засега ще изпуснем тази част и ще напишем "фалшиво" решение, за по-лесно.

## Въвеждане на вход

Първите две стъпки са прости:

``` ruby
puts "Please enter one of: rock, paper, scissors"
user_choice = gets.chomp
```

*Базови познания: [метод](methods.md)*

Първия ред използва метода `puts`, за да извади низ на екрана. Вместо "метод", можем да наречем `puts` "действие", на което подаваме някакъв низ и то го извежда на екрана. Метода `gets` прави обратното -- спира изпълнението на програмата и чака потребителя да въведе един цял ред. Върху това, което връща (низа от потребителя), извикваме метода `chomp`, който премахва последния `enter` клавиш, който сме въвели.

    TODO: не ми харесва извикването на метод върху gets тук. Влизаме в сложни
    води -- извиква се действие върху субект, това-онова. Може би има логика
    тук да кажем, че `gets.chomp` връща реда, и да оставим един линк, към
    документ, който задълбава в това какво е "метод" и как се вика върху
    субекти. С напълно отделен пример.

    TODO: Дали няма да е малко по-ясно ако сложим `user_choice = gets` и после `user_choice = user_choice.chomp`?

*Базови познания: [низ](strings.md)*

Този ред "поставяме" в променливата `user_choice`. Самия ред е някакъв низ, който си виси в паметта на компютъра. С действието `user_choice = <нещо>`, ние създаваме "етикет", който можем да използваме, за да се обърнем към този низ.

Сега трябва да решим какъв ще е избора на компютъра, но за удобство, нека просто да решим да е винаги един и същ:

``` ruby
computer_choice = "scissors"
```

Тук правим същото, като с `user_choice` по-горе, само че вместо да вземем низ от потребителя, просто го поставяме в променливата `computer_choice` (тоест, създаваме "етикет" `computer_choice`, който сочи към низа "scissors")

Остава да изведем някакъв резултат, но все още не знаем как да сравним резултатите (дори и избора на компютъра да е само един). Затова просто ще изведем кой какво е изиграл и ще сложим фалшиво съобщение за победа:

``` ruby
puts "You played:      #{user_choice}"
puts "Computer played: #{computer_choice}"
puts "You win!"
```

В случая съобщението е правилно, но ако променим избора на потребителя на "paper", вече няма да бъде. Затова следващата стъпка ще е да сравним двата избора и да решим какво да изведем на екрана в зависимост от това кой наистина е победил.

Ето целия код, който написахме до момента:

``` ruby
puts "Please enter one of: rock, paper, scissors"
user_choice = gets.chomp

computer_choice = "scissors"

puts "You played:      #{user_choice}"
puts "Computer played: #{computer_choice}"
puts "You win!"
```

Следваща статия: [If/else](02_rps_if_else.md)
